<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2025/01/21/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Pinctrl和GPIO子系统</title>
    <url>/2025/01/16/Pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%92%8CGPIO%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="Pinctrl和GPIO子系统"><a href="#Pinctrl和GPIO子系统" class="headerlink" title="Pinctrl和GPIO子系统"></a>Pinctrl和GPIO子系统</h1><p><strong>引言</strong> </p>
<p>在Linux系统中Pinctrl子系统和GPIO子系统是非常重要的概念，他们共同负责和管理SoC（system on a Chip）上的引脚。这两个子系统相互协作，为驱动开发提供一个灵活且高效的接口，用于配置和控制硬件引脚。</p>
<span id="more"></span>

<h2 id="Pinctrl子系统"><a href="#Pinctrl子系统" class="headerlink" title="Pinctrl子系统"></a>Pinctrl子系统</h2><p>Pinctrl，即Pin Conctroller，中文翻译为引脚控制器。它是一个虚拟的概念，主要用与设置IOMUX（input&#x2F;output Multiplexer），将某个引脚链接到指定的模块，从而实现特定的功能。</p>
<p><strong>Pinctrl的作用</strong></p>
<ul>
<li>引脚复用：一个引脚可以被配置为多种功能（如GPIO、UART、IIC等），Pinctrl子系统负责管理这些服用配置。</li>
<li>引脚配置：设置引脚的电气特性，如输入输出模式、驱动能力、上拉下拉等。、</li>
<li>设备树集成：通过设备树描述硬件，pingctrl子系统更具设备树配置自动完成引脚的初始化。</li>
</ul>
<p><strong>Pinctrl的工作原理</strong></p>
<p>1、<strong>设备树描述</strong>：在设备树中，我们为每个引脚配置定义一个pinctrl-name属性，为这个属性	指定该引脚可以具有的各种状态。</p>
<p>2、<strong>Pinctrl驱动</strong>：pinctrl驱动程序会根据设备树中的配置，初始化pinctrl子系统。</p>
<p>3、<strong>驱动程序的使用</strong>：当一个设备的驱动程序需要使用某个引脚时，它会通过pinctrl子系统申请并配置引脚。</p>
<p>4、<strong>pinctrl子系统的配置</strong>：pinctrl子系统会根据驱动程序的请求，设置相应的寄存器，完成引脚的复用和配置。</p>
<h5 id="1、pinctrl节点介绍"><a href="#1、pinctrl节点介绍" class="headerlink" title="1、pinctrl节点介绍"></a>1、pinctrl节点介绍</h5><p>首先我们可以在linux-5.4.31&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;stm32mp151-pinctrl.dtsi文件中找到pinctrl节点。或者也可以使用<code> grep &quot;pinctrl:&quot; stm32mp15*</code> 在dts目录下搜索。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">soc &#123;</span><br><span class="line">     pinctrl: pin-controller@50002000 &#123;</span><br><span class="line">         #address-cells = &lt;1&gt;;</span><br><span class="line">         #size-cells = &lt;1&gt;;</span><br><span class="line">         compatible = &quot;st,stm32mp157-pinctrl&quot;;</span><br><span class="line">         ranges = &lt;0 0x50002000 0xa400&gt;;</span><br><span class="line">         interrupt-parent = &lt;&amp;exti&gt;;</span><br><span class="line">         st,syscfg = &lt;&amp;exti 0x60 0xff&gt;;</span><br><span class="line">         hwlocks = &lt;&amp;hsem 0&gt;;</span><br><span class="line">         pins-are-numbered;</span><br><span class="line">     &#125;</span><br><span class="line"> /* 剩下内容省略 */</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>soc{…}：这表示pinctrl节点是soc根节点下的一个子节点，在设备树中，soc节点是描述整个片上系统。</li>
<li>pinctrl：节点标签，方便其他地方引用节点。</li>
<li>#address-cells、#address-cells：定义了地址单元、大小单元的数量。（也就是reg属性里面的数量）。</li>
<li>compatible：兼容性字符串，用于驱动的匹配。（很重要）（书写规范：从最具体到最通用的顺序排列，首先是制造商 的名称，然后是设备的型号或者设备类型的描述）</li>
<li>ranges：该属性定义了父地址空间和子地址空间的映射关系。0：父地址空间的起始地址偏移量为0；0x50002000：子地址空间的起始地址；0xa400：子地址空间的大小。<ul>
<li>rangs与reg两个的区别：reg属性时用来描述父节点的地址空间的地址和大小，是物理地址直接链接在内存总线上的。而rangs属性是用与父节点和子节点之间建立隐射关系的。</li>
</ul>
</li>
<li>interrupt-parent：中断的父节点。</li>
<li>st,syscfg：stm特定的属性，用于配置系统配置寄存器的。</li>
<li>hwlocks：该节点的硬件锁，&amp;hsem，0：表示使用hsem节点的第一个硬件信号量。</li>
<li>pins-are-numbered：这个是一个标记属性，表示该引脚控制器使用数字编号来表示引脚。</li>
</ul>
<p>该文件是由芯片厂商官方将芯片的通用部分单独提出来的一些设备树的配置信息，在soc节点中汇总了所需的配置信息。</p>
<p>在设备树的只要配置文件的stm32mp15-pinctrl.dtsi文件中，我们可以搜索到很多的配置信息。大概如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;pinctrl &#123;</span><br><span class="line">        adc1_in6_pins_a: adc1-in6 &#123;</span><br><span class="line">                pins &#123;</span><br><span class="line">                        pinmux = &lt;STM32_PINMUX(&#x27;F&#x27;, 12, ANALOG)&gt;;</span><br><span class="line">                &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        adc12_ain_pins_a: adc12-ain-0 &#123;</span><br><span class="line">                pins &#123;</span><br><span class="line">                        pinmux = &lt;STM32_PINMUX(&#x27;C&#x27;, 3, ANALOG)&gt;, /* ADC1 in13 */</span><br><span class="line">                                 &lt;STM32_PINMUX(&#x27;F&#x27;, 12, ANALOG)&gt;, /* ADC1 in6 */</span><br><span class="line">                                 &lt;STM32_PINMUX(&#x27;F&#x27;, 13, ANALOG)&gt;, /* ADC2 in2 */</span><br><span class="line">                                 &lt;STM32_PINMUX(&#x27;F&#x27;, 14, ANALOG)&gt;; /* ADC2 in6 */</span><br><span class="line">                &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>&amp;pinctrl：这是一个引用。相当一在上面结果的pinctrl节点中添加的子节点。</li>
<li>adc1_in6_pins_a: adc1-in6 { … }：标签和名称。</li>
<li>pins{…}：pins节点包含具体的引脚配置。</li>
<li>pinmux：用于配置引脚的复用功能。</li>
<li>&lt;STM32_PINMUX(‘F’, 12, ANALOG)&gt;：这行代码的含义是将 PF12 引脚配置为 ADC1 的输入通道 6。</li>
</ul>
<h2 id="GPIO子系统"><a href="#GPIO子系统" class="headerlink" title="GPIO子系统"></a>GPIO子系统</h2><h4 id="1、GPIO子系统的作用"><a href="#1、GPIO子系统的作用" class="headerlink" title="1、GPIO子系统的作用"></a>1、GPIO子系统的作用</h4><p>GPIO（通用输入&#x2F;输出）是微控制器或者片上系统（soc）上最基本的外设之一。GPIO引脚乐意配置为输入或者输出，用于与外部设备进行数字信号的交互。</p>
<h4 id="2、GPIO子系统的组成部分"><a href="#2、GPIO子系统的组成部分" class="headerlink" title="2、GPIO子系统的组成部分"></a>2、GPIO子系统的组成部分</h4><ul>
<li>gpiolib核心：GPIO子系统的核心框架，提供了一组同的API函数，共驱动使用。</li>
<li>GPIO控制器驱动：每一个soc都有自己的GPIO控制器，需要相应的驱动程序来管理这些控制器。</li>
<li>设备树绑定：设备树用于描述硬件信息。</li>
</ul>
<h4 id="3、GPIO子系统的API"><a href="#3、GPIO子系统的API" class="headerlink" title="3、GPIO子系统的API"></a>3、GPIO子系统的API</h4><p>GPIO有两套API：</p>
<ul>
<li>基于描述符的API：新的API，函数以gpiod—为开头，它使用gpio-desc结构体表示一个gpio引脚。</li>
<li>传统的API：函数以gpio-为开头，使用一个整数来表示一个gpio引脚。</li>
</ul>
<h1 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h1><p><strong>功能实现：</strong> </p>
<ul>
<li>使用pinctrl子系统和GPIO子系统。</li>
<li>使用设备树。</li>
<li>点亮led灯。</li>
</ul>
<p><strong>子系统的讲解：</strong> </p>
<ul>
<li><p>在内核代码的&#x2F;home&#x2F;h&#x2F;h&#x2F;linux-5.4.31&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;stm32mp157a-fsmp1a.dts目录下，添加设备树的节点。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">led_test2&#123;</span><br><span class="line">      compatible = &quot;h,led2&quot;;</span><br><span class="line">      led_name = &quot;led02&quot;;</span><br><span class="line">      led_minor = &lt;10&gt;;</span><br><span class="line">      gpios = &lt;&amp;gpioz 5 GPIO_ACTIVE_HIGH&gt;,</span><br><span class="line">              &lt;&amp;gpioz 6 GPIO_ACTIVE_HIGH&gt;,</span><br><span class="line">              &lt;&amp;gpioz 7 GPIO_ACTIVE_HIGH&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>其中gpios是在dts&#x2F;stm32mp151.dtsi文件中的gpioz节点中追加。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gpioz: gpio@54004000 &#123;</span><br><span class="line">    gpio-controller;</span><br><span class="line">    #gpio-cells = &lt;2&gt;;</span><br><span class="line">    interrupt-controller;</span><br><span class="line">    #interrupt-cells = &lt;2&gt;;</span><br><span class="line">    reg = &lt;0 0x400&gt;;</span><br><span class="line">    clocks = &lt;&amp;scmi0_clk CK_SCMI0_GPIOZ&gt;;</span><br><span class="line">    st,bank-name = &quot;GPIOZ&quot;;</span><br><span class="line">    st,bank-ioport = &lt;11&gt;;</span><br><span class="line">    status = &quot;disabled&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新编译设备树。运行下面命令。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">h@h-virtual-machine:~/h/linux-5.4.31$ make -j4 ARCH=arm dtbs LOADADDR=0xC2000040</span><br><span class="line">  DTC     arch/arm/boot/dts/stm32mp157a-fsmp1a.dtb</span><br><span class="line">h@h-virtual-machine:~/h/linux-5.4.31$ cp -raf arch/arm/boot/dts/stm32mp157a-fsmp1a.dtb /tftpboot/</span><br></pre></td></tr></table></figure>
</li>
<li><p>这样我们编写的设备树文件会重新编译并在重新启动板子的时候加载到芯片中。</p>
</li>
</ul>
<p><strong>平台驱动程序讲解：</strong> </p>
<ul>
<li><p>编写驱动框架代码。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int __init led_pdrv_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    printk(&quot;-------%s----------\n&quot;,__FUNCTION__);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __exit led_pdrv_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">    printk(&quot;-------%s----------\n&quot;,__FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(led_pdrv_init);</span><br><span class="line">module_exit(led_pdrv_exit);</span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>框架搭好的了之后，开始写注册平台驱动。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;linux/init.h&gt;</span><br><span class="line">#include &lt;linux/module.h&gt;</span><br><span class="line">#include &lt;linux/miscdevice.h&gt;</span><br><span class="line">#include &lt;linux/platform_device.h&gt;</span><br><span class="line">#include &lt;linux/slab.h&gt;</span><br><span class="line">#include &lt;linux/fs.h&gt;</span><br><span class="line">#include &lt;linux/io.h&gt;</span><br><span class="line">#include &lt;linux/uaccess.h&gt;</span><br><span class="line">#include &lt;linux/mod_devicetable.h&gt;</span><br><span class="line">#include &lt;linux/of.h&gt;</span><br><span class="line">#include &lt;linux/of_gpio.h&gt;</span><br><span class="line">#include &lt;linux/gpio.h&gt;</span><br><span class="line"></span><br><span class="line">int led_probe(struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">    printk(&quot;-------%s----------\n&quot;,__FUNCTION__);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">int led_remove(struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">    printk(&quot;-------%s----------\n&quot;,__FUNCTION__);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct of_device_id led_match_table[] = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        .compatible = &quot;h,led2&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct platform_driver led_pdrv = &#123;</span><br><span class="line">    .probe = led_probe,</span><br><span class="line">    .remove = led_remove,</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = &quot;led_pdrv&quot;,</span><br><span class="line">        .of_match_table = led_match_table,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static int __init led_pdrv_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    printk(&quot;-------%s----------\n&quot;,__FUNCTION__);</span><br><span class="line">    return platform_driver_register(&amp;led_pdrv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __exit led_pdrv_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">    printk(&quot;-------%s----------\n&quot;,__FUNCTION__);</span><br><span class="line">    platform_driver_unregister(&amp;led_pdrv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(led_pdrv_init);</span><br><span class="line">module_exit(led_pdrv_exit);</span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br></pre></td></tr></table></figure>

<ul>
<li>其中<code>struct platform_driver led_pdrv</code> 结构体是很重要的，probe函数是在驱动和设备树上的节点匹配之后，内核自动调用的。remove是在内核卸载是调用的。driver中的name是平台驱动的名字。of_match_table的作用是与设备树进行匹配用的，通过compatible进行匹配。</li>
</ul>
</li>
<li><p>平台驱动,probe函数的实现</p>
<ul>
<li><p>为自己创建的结构体申请空间</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct stm32mp157_led &#123;</span><br><span class="line">    struct miscdevice misc; // 直接定义miscdevice结构体</span><br><span class="line">    struct device_node *np;</span><br><span class="line">    int gpio_5;</span><br><span class="line">    int gpio_6;</span><br><span class="line">    int gpio_7;</span><br><span class="line">&#125;;</span><br><span class="line">struct stm32mp157_led *led_t;</span><br><span class="line"></span><br><span class="line">    led_t = kzalloc(sizeof(*led_t), GFP_KERNEL);</span><br><span class="line">    if (!led_t) &#123;</span><br><span class="line">        printk(KERN_ERR &quot;led kzalloc failed\n&quot;);</span><br><span class="line">        return -ENOMEM;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取设备树节点属性，为创建杂项设备做准备</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">led_t-&gt;np = pdev-&gt;dev.of_node;</span><br><span class="line">of_property_read_u32(led_t-&gt;np, &quot;led_minor&quot;, &amp;minor);</span><br><span class="line">of_property_read_string(led_t-&gt;np, &quot;led_name&quot;, (const char 	**)&amp;name);</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化杂项设备和注册。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//初始化杂项设备</span><br><span class="line">led_t-&gt;misc.minor = minor;</span><br><span class="line">led_t-&gt;misc.name = name;</span><br><span class="line">led_t-&gt;misc.fops = &amp;led_fops;</span><br><span class="line">        </span><br><span class="line">// 注册杂项设备</span><br><span class="line">ret = misc_register(led_t-&gt;misc);</span><br><span class="line">if(ret)</span><br><span class="line">&#123;</span><br><span class="line">    printk(&quot;misc register faile\n&quot;);</span><br><span class="line">    goto err_misc_register;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>申请gpio资源</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 申请gpio资源</span><br><span class="line">led_t-&gt;gpio_5 = of_get_gpio(led_t-&gt;np, 0);</span><br><span class="line">led_t-&gt;gpio_6 = of_get_gpio(led_t-&gt;np, 1);</span><br><span class="line">led_t-&gt;gpio_7 = of_get_gpio(led_t-&gt;np, 2);</span><br></pre></td></tr></table></figure>
</li>
<li><p>错误跳转</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">err_misc_register:</span><br><span class="line">    kfree(led_t);</span><br><span class="line">    return ret;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>平台驱动的remove函数实现</p>
<ul>
<li><p>注销和卸载</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">misc_deregister(led_t-&gt;misc);</span><br><span class="line">kfree(led_t);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>文件操作函数write函数</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssize_t led_write (struct file *file, const char __user *buf, size_t size, loff_t *loff)</span><br><span class="line">&#123;</span><br><span class="line">    int ret = 0;</span><br><span class="line">    int value;</span><br><span class="line">    printk(&quot;-------%s----------\n&quot;,__FUNCTION__);</span><br><span class="line">    // 将应用数据转换为内核数据</span><br><span class="line">    ret = copy_from_user(&amp;value, buf, size);</span><br><span class="line">    if (ret) &#123;</span><br><span class="line">        printk(&quot;copy from user error\n&quot;);</span><br><span class="line">        return -EAGAIN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gpio_request(led_t-&gt;gpio_5, &quot;led_5&quot;);</span><br><span class="line">    gpio_request(led_t-&gt;gpio_6, &quot;led_6&quot;);</span><br><span class="line">    gpio_request(led_t-&gt;gpio_7, &quot;led_7&quot;);</span><br><span class="line"></span><br><span class="line">    if (value) &#123;   // 开灯</span><br><span class="line">        gpio_direction_output(led_t-&gt;gpio_5, 1);</span><br><span class="line">        gpio_direction_output(led_t-&gt;gpio_6, 1);</span><br><span class="line">        gpio_direction_output(led_t-&gt;gpio_7, 1);</span><br><span class="line">    &#125; else &#123;  // 关灯</span><br><span class="line">        gpio_direction_output(led_t-&gt;gpio_5, 0);</span><br><span class="line">        gpio_direction_output(led_t-&gt;gpio_6, 0);</span><br><span class="line">        gpio_direction_output(led_t-&gt;gpio_7, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gpio_free(led_t-&gt;gpio_5);</span><br><span class="line">    gpio_free(led_t-&gt;gpio_6);</span><br><span class="line">    gpio_free(led_t-&gt;gpio_7);</span><br><span class="line"></span><br><span class="line">    return size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>应用程序led_app.c</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc,char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    int fd;</span><br><span class="line">    int on;</span><br><span class="line"></span><br><span class="line">    fd = open(argv[1], O_RDWR);</span><br><span class="line">    if(fd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;open faile\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        on = 1;</span><br><span class="line">        write(fd, &amp;on, sizeof(on));</span><br><span class="line">        sleep(1);</span><br><span class="line">        on = 0;</span><br><span class="line">        write(fd, &amp;on, sizeof(on));</span><br><span class="line">        sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Makefile文件</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">KERN_DIR = /home/h/h/linux-5.4.31</span><br><span class="line">DRV_DIR := $(shell pwd)  # 获取当前工作目录</span><br><span class="line">MODULE_NAME = led_pdrv</span><br><span class="line">APP_NAME = led_app</span><br><span class="line"></span><br><span class="line">all:</span><br><span class="line">	make -C $(KERN_DIR) M=$(DRV_DIR) modules</span><br><span class="line">	$(CC) -o $(APP_NAME) $(APP_NAME).c</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">	make -C $(KERN_DIR) M=$(DRV_DIR) clean</span><br><span class="line">	rm -rf $(APP_NAME)</span><br><span class="line"></span><br><span class="line">install:</span><br><span class="line">	cp -raf *.ko /opt/myrootfs/drv_module</span><br><span class="line">	cp -raf $(APP_NAME) /opt/myrootfs/drv_module</span><br><span class="line"></span><br><span class="line">obj-m += $(MODULE_NAME).o</span><br></pre></td></tr></table></figure>

<p><strong>下载验证</strong> </p>
<ul>
<li><p>在文件目录下，输入<code>make</code> 命令，进行编译，成功后，再输入<code>make install</code> 将编译的文件加载到内核中。</p>
</li>
<li><p>重新启动下载板子。</p>
</li>
<li><p>在串口助手的端口中找到存放代码的文件，可以发现有两个文件。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">led_app led_pdrv.ko</span><br></pre></td></tr></table></figure>
</li>
<li><p>输入<code>insmod led_pdrv.ko</code> 命令加载驱动。</p>
</li>
<li><p>成功后，可以在&#x2F;dev目录下找平台设备文件。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># ls /dev/led02 -n</span><br><span class="line">crw-rw----    1 0        0          10,  10 Jan  5 14:04 /dev/led02</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>然后加载应用程序就可以了。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./led_app /dev/led02</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Linux驱动</category>
      </categories>
      <tags>
        <tag>Pinctrl子系统</tag>
        <tag>GPIO子系统</tag>
        <tag>Linux学习</tag>
      </tags>
  </entry>
  <entry>
    <title>测试文章</title>
    <url>/2025/01/21/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<p>这是以个测试</p>
<p><img src="/2025/01/21/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/20241108123904.jpg" alt="微信图片_20241108123904"></p>
]]></content>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>杂项设备</title>
    <url>/2025/01/14/%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/</url>
    <content><![CDATA[<h1 id="杂项设备的使用流程"><a href="#杂项设备的使用流程" class="headerlink" title="杂项设备的使用流程"></a>杂项设备的使用流程</h1><h5 id="1、杂项设备（misc-device）"><a href="#1、杂项设备（misc-device）" class="headerlink" title="1、杂项设备（misc device）"></a>1、杂项设备（misc device）</h5><ul>
<li><p>概念：</p>
<p> 杂项设备是linux内核提供的一种字符设备驱动矿建，用于管理那些功能比较简单、数量较少的设备。</p>
</li>
<li><p>特点：</p>
<p>  主设备号固定为10，通过次设备号来区分不同的杂项设备。</p>
<p>  结构简单</p>
<p>  提供基本的读写操作接口</p>
</li>
</ul>
<span id="more"></span>

<h5 id="2、驱动开发流程及其讲解"><a href="#2、驱动开发流程及其讲解" class="headerlink" title="2、驱动开发流程及其讲解"></a>2、驱动开发流程及其讲解</h5><p>​	1、包含头文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;linux/module.h&gt;</span><br><span class="line">#include &lt;linux/fs.h&gt;</span><br><span class="line">#include &lt;linux/miscdevice.h&gt;</span><br></pre></td></tr></table></figure>

<p>​	2、定义文件操作结构体</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const struct file_operations led_fops = &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .open   = led_pdrv_open,</span><br><span class="line">    .write  = led_pdrv_write,</span><br><span class="line">    .release  = led_pdrv_close,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	3、定义杂项设备结构体</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct miscdevice misc;</span><br><span class="line"></span><br><span class="line">struct miscdevice  &#123;</span><br><span class="line">	int minor;</span><br><span class="line">	const char *name;</span><br><span class="line">	const struct file_operations *fops;</span><br><span class="line">	struct list_head list;</span><br><span class="line">	struct device *parent;</span><br><span class="line">	struct device *this_device;</span><br><span class="line">	const struct attribute_group **groups;</span><br><span class="line">	const char *nodename;</span><br><span class="line">	umode_t mode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	参数：</p>
<pre><code>	* minor：次设备号。
	* name：设备节点名称。
	* fops：文件操作结构体指针。
	* 其他的用到的不多，用到可以在搜。
</code></pre>
<p>​	4、注册杂项设备</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    ret = misc_register(&amp;led_dev-&gt;misc);</span><br><span class="line">    if (ret) &#123;</span><br><span class="line">        printk(&quot;misc register failed\n&quot;);</span><br><span class="line">        goto err_kfree;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">int misc_register(struct miscdevice *misc)</span><br><span class="line">&#123;</span><br><span class="line">	dev_t dev;</span><br><span class="line">	int err = 0;</span><br><span class="line">	bool is_dynamic = (misc-&gt;minor == MISC_DYNAMIC_MINOR);</span><br><span class="line"></span><br><span class="line">	INIT_LIST_HEAD(&amp;misc-&gt;list);</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;misc_mtx);</span><br><span class="line"></span><br><span class="line">	if (is_dynamic) &#123;</span><br><span class="line">		int i = find_first_zero_bit(misc_minors, DYNAMIC_MINORS);</span><br><span class="line"></span><br><span class="line">		if (i &gt;= DYNAMIC_MINORS) &#123;</span><br><span class="line">			err = -EBUSY;</span><br><span class="line">			goto out;</span><br><span class="line">		&#125;</span><br><span class="line">		misc-&gt;minor = DYNAMIC_MINORS - i - 1;</span><br><span class="line">		set_bit(i, misc_minors);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		struct miscdevice *c;</span><br><span class="line"></span><br><span class="line">		list_for_each_entry(c, &amp;misc_list, list) &#123;</span><br><span class="line">			if (c-&gt;minor == misc-&gt;minor) &#123;</span><br><span class="line">				err = -EBUSY;</span><br><span class="line">				goto out;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dev = MKDEV(MISC_MAJOR, misc-&gt;minor);</span><br><span class="line"></span><br><span class="line">	misc-&gt;this_device =</span><br><span class="line">		device_create_with_groups(misc_class, misc-&gt;parent, dev,</span><br><span class="line">					  misc, misc-&gt;groups, &quot;%s&quot;, misc-&gt;name);</span><br><span class="line">	if (IS_ERR(misc-&gt;this_device)) &#123;</span><br><span class="line">		if (is_dynamic) &#123;</span><br><span class="line">			int i = DYNAMIC_MINORS - misc-&gt;minor - 1;</span><br><span class="line"></span><br><span class="line">			if (i &lt; DYNAMIC_MINORS &amp;&amp; i &gt;= 0)</span><br><span class="line">				clear_bit(i, misc_minors);</span><br><span class="line">			misc-&gt;minor = MISC_DYNAMIC_MINOR;</span><br><span class="line">		&#125;</span><br><span class="line">		err = PTR_ERR(misc-&gt;this_device);</span><br><span class="line">		goto out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Add it to the front, so that later devices can &quot;override&quot;</span><br><span class="line">	 * earlier defaults</span><br><span class="line">	 */</span><br><span class="line">	list_add(&amp;misc-&gt;list, &amp;misc_list);</span><br><span class="line"> out:</span><br><span class="line">	mutex_unlock(&amp;misc_mtx);</span><br><span class="line">	return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	5、注销杂项设备</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">misc_deregister(&amp;led_dev-&gt;misc);</span><br></pre></td></tr></table></figure>



<h5 id="3、杂项设备的使用"><a href="#3、杂项设备的使用" class="headerlink" title="3、杂项设备的使用"></a>3、杂项设备的使用</h5><ul>
<li><p>创建设备节点：</p>
<p> 注册杂项设备后，在系统的&#x2F;dev&#x2F;目录下会自动创建一个设备节点。</p>
</li>
<li><p>应用程序访问：</p>
<p>  应用程序可以通过系统调用（如open、write、read）来访问该设备节点，从而与驱动进行交互。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux驱动</category>
      </categories>
      <tags>
        <tag>Linux学习</tag>
        <tag>杂项设备</tag>
        <tag>平台总线</tag>
      </tags>
  </entry>
  <entry>
    <title>ARM Cortex-M3 M4</title>
    <url>/2025/01/20/ARM-Cortex-M3-M4/</url>
    <content><![CDATA[<h1 id="ARM-Cortex-M3-M4"><a href="#ARM-Cortex-M3-M4" class="headerlink" title="ARM Cortex-M3 M4"></a>ARM Cortex-M3 M4</h1><p><strong>引言</strong> </p>
<p>ARM Cortex-M3 M4是ARM公司推出的32RISC（精简指令集计算机）处理器内核，用于各种嵌入式系统中。</p>
<span id="more"></span>

<h4 id="第一章-ARM-Cortex-M-处理器简介"><a href="#第一章-ARM-Cortex-M-处理器简介" class="headerlink" title="第一章 ARM Cortex-M 处理器简介"></a>第一章 ARM Cortex-M 处理器简介</h4><h5 id="1-1-什么是ARM-Cortex-M处理器"><a href="#1-1-什么是ARM-Cortex-M处理器" class="headerlink" title="1.1 什么是ARM Cortex-M处理器"></a>1.1 什么是ARM Cortex-M处理器</h5><p>Cortex-M3和M4为cortex处理器中的第一个，M3和M4处理器使用32位架构，寄存器组中的内部寄存器、数据通路以及总线接口都是32位的，Cortex-M处理器使用指令集架构（ISA）为Thumb ISA，其基于Thumb-2技术并同时支持16位和32位指令。</p>
<p><strong>指令集架构</strong> </p>
<p>指令集架构定义了以下的内容：</p>
<ul>
<li>处理器可以之心那个的指令集合：例如加法、减法、乘法、除法、数据加载、数据存储、跳转等。每条指令都有特定的二进制编码。</li>
<li>指令格式：指令由哪些部分组成，例如操作码、操作数等</li>
<li>寄存器组织：处理器内部有哪些寄存器，每个寄存器的用途和大小。</li>
<li>寻址方式：如何访问存储器中数据，例如立即数寻址、寄存器寻址、直接寻址、间接寻址等。（这是汇编的知识）</li>
<li>铸锻和异常处理：如何响应外部中断和内部异常。</li>
</ul>
<p>ISA是软件和硬件之间的接口，程序员通过使用ISA定义的指令来编写程序，而硬件则根据ISA的定义来执行这些指令。不同的处理器有不同的ISA，例如X86、ARM、MIPS、RISC-V等</p>
<p><strong>Thumb-2技术：</strong> 后来的ARM架构引入了Thumb-2技术，它扩展了Thumb指令集，增加了32位指令，使得Thumb指令集更加强大和灵活，几乎可以替代传统的ARM指令集，同时保持了较高的代码密度。Cortex-M系列处理器主要使用Thumb-2技术。</p>
<p>共同点：</p>
<ul>
<li><p>哈佛总线架构，且具有统一的存储器空间：指令和地址总线使用相同的地址空间。<br>  地址空间是CPU可以访问的存储器地址的范围。例如，一个32位处理器的地址空间为2^32个字节（4GB）。</p>
</li>
<li><p>架构基础：cortex-M3和M4基于相同的架构（ARMv7-M）。</p>
</li>
<li><p>Thumb-2指令集：支持16位和32位的混合指令，兼顾代码密度和性能。</p>
</li>
<li><p>3级流水线：提高指令执行效率。</p>
</li>
<li><p>NVIC：高效的中断管理。</p>
</li>
<li><p>存储器保护单元（MPU）：提供内存保护，增强系统可靠性。</p>
</li>
<li><p>调试接口：支持JTAG和SWD调式。</p>
</li>
<li><p>指令兼容性：Cortex-M3编写的二进制指令无需修改就可用在Cortex-M4上执行。</p>
</li>
</ul>
<p>主要区别：</p>
<ul>
<li>Cortex-M在Cortex-M3的基础上增加了DSP功能，是器更加适合处理信号处理的应用。</li>
<li>DSP拓展指令集：Cortex-M4包含一系列优化的DSP指令。</li>
<li>浮点单元（FPU）：Cortex-M4可以选择支撑单精度浮点运算单元，童工硬件浮点运算支持。</li>
</ul>
<h6 id="Cortex-M处理器家族"><a href="#Cortex-M处理器家族" class="headerlink" title="Cortex-M处理器家族"></a>Cortex-M处理器家族</h6><p><img src="/2025/01/20/ARM-Cortex-M3-M4/1150.png" alt="1150"></p>
<p>Cortex-M3和M4处理器基于ARMv7-M架构，既有高性能且为微控制器应用设计的。</p>
<h6 id="处理器和为控制器的区别"><a href="#处理器和为控制器的区别" class="headerlink" title="处理器和为控制器的区别"></a>处理器和为控制器的区别</h6><p>ARM公司不生产微控制器，ARM设计的处理器及多种部件都是芯片制造商所需要的，ARM会对包括微控制器供应商在内的各家芯片设备公司授权，也被称为IP授权。</p>
<p>在一个典型的微控制器设计中，处理器只会占用芯片中的一小块区域。在其他部分则成为存储器、时钟生成和分配逻辑、系统总线、外设等。</p>
<p><img src="/2025/01/20/ARM-Cortex-M3-M4/151510.png" alt="image-20250120151523458"></p>
<p>许多微控制器供应商选择ARM Cortex-M处理器作为它们的CPU，但是存储器映射系统、存储器映射、外设及操作特性（时钟频率和电压）各不相同，就构成了微控制器产品的多样性。</p>
<h5 id="1-2-C程序中的数据类型"><a href="#1-2-C程序中的数据类型" class="headerlink" title="1.2 C程序中的数据类型"></a>1.2 C程序中的数据类型</h5><p><img src="/2025/01/20/ARM-Cortex-M3-M4/154947.png" alt="image-20250120154950338"></p>
]]></content>
      <categories>
        <category>ARM Cortex-M3 M4</category>
      </categories>
      <tags>
        <tag>stm32学习</tag>
        <tag>ARM Cortex-M3</tag>
        <tag>ARM Cortex-M4</tag>
      </tags>
  </entry>
  <entry>
    <title>设备树</title>
    <url>/2025/01/07/%E8%AE%BE%E5%A4%87%E6%A0%91/</url>
    <content><![CDATA[<h1 id="设备树"><a href="#设备树" class="headerlink" title="设备树"></a>设备树</h1><p>linux3.0以后版本才引进了设备树，在此之前的linux内核代码中描述硬件平台信息的代码散乱的分布在arch&#x2F;arm&#x2F;plat-XXX 和 arch&#x2F;arm&#x2F;mach-XXX等目录中。所以为了改善这一情况，设备树孕育于出，它将这些硬件描述信息从内核代码中剥离出来，使用一种树形结构来描述硬件平台的组成和配置信息。</p>
<p>具体关于设备树的介绍可以参考：<a href="https://www.devicetree.org/">https://www.devicetree.org/</a></p>
<span id="more"></span>

<h2 id="1、设备树简介"><a href="#1、设备树简介" class="headerlink" title="1、设备树简介"></a>1、设备树简介</h2><h5 id="1、什么是设备树？（Device-Tree）"><a href="#1、什么是设备树？（Device-Tree）" class="headerlink" title="1、什么是设备树？（Device Tree）"></a>1、什么是设备树？（Device Tree）</h5><p>​	在linux内核早期，平台硬件的信息（例如内存地址、外设配置等）是直接编码在内核代码中的。这意味着一旦硬件平台发生改变，就要重新编写代码。这种方式难以维护和移植。</p>
<p>​	为了解决这一问题，linux内核在3.X版本之后开时引用了设备树机制。<strong>简单的来说，设备树就是一个描述硬件平台的信息的文本文件，内核通过解析这个文件来了解硬件平台的配置。</strong></p>
<h5 id="2、设备树的作用"><a href="#2、设备树的作用" class="headerlink" title="2、设备树的作用"></a>2、设备树的作用</h5><p>​	设备的主要作用：</p>
<ul>
<li>描述硬件的拓扑结构：使用树形结构可以清晰的描述硬件平台上的各种设备以及相互的关系。例如哪个USART链接着哪些GOIO控制器，哪个中断控制器控制着那个外设的中断。</li>
<li>传递硬件配置信息：将硬件设备的地址、中断号、时钟频率等配置信息传递给内核。</li>
<li>实现硬件描述与驱动代码的分离：使得驱动程序更见通用，时许更具设备树中的信息进行适当的调整，而无需修改驱动代码。</li>
</ul>
<h5 id="3、设备树的基本概念"><a href="#3、设备树的基本概念" class="headerlink" title="3、设备树的基本概念"></a>3、设备树的基本概念</h5><p>​	设备树有节点（node）和属性（property）组成，形成一个树状结构。</p>
<ul>
<li><p>节点（node）：代表硬件设备，例如内存、外设（USART、SPI、IIC等）。每个节点都有唯一的名称。并且包含多个属性。节点之间存在着父子关系。根节点可以用‘&#x2F;’表示。</p>
</li>
<li><p>属性（property）：描述节点的特性，例如设备的地址（reg）、中断号（interrupts）、时钟频率（clock-frequency）等。属性有键值成对组成，键是属性的名称，值属性的数据。</p>
</li>
<li><p>举一个简单的例子：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/ &#123;  // 根节点</span><br><span class="line">    compatible = &quot;my-company,my-platform&quot;; // 兼容性字符串，用于驱动匹配</span><br><span class="line">    model = &quot;My Platform v1.0&quot;; // 平台型号</span><br><span class="line"></span><br><span class="line">    memory &#123; // 内存节点</span><br><span class="line">        reg = &lt;0x40000000 0x10000000&gt;; // 内存起始地址和大小</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    uart0: uart@1000 &#123; // UART 节点，命名为 uart0，地址为 0x1000</span><br><span class="line">        compatible = &quot;ns16550a&quot;; // UART 控制器类型</span><br><span class="line">        reg = &lt;0x1000 0x100&gt;; // UART 寄存器地址和大小</span><br><span class="line">        interrupts = ; // UART 中断号</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="4、设备树的表示形式：DTS、DTB、DTC"><a href="#4、设备树的表示形式：DTS、DTB、DTC" class="headerlink" title="4、设备树的表示形式：DTS、DTB、DTC"></a>4、设备树的表示形式：DTS、DTB、DTC</h5><ul>
<li><p>DTS（Device Tree Source）：设备树的源文件，以.dts为结尾的文件。在使用时可以像C语言中引用头文件一样使用<code>#include</code>指令。</p>
</li>
<li><p>DTC（Device Tree Compiler）：设备树的编译器。是一个工具程序，类似于gcc，可以将DTS文件编一个二进制的DTB文件。</p>
</li>
<li><p>DTB（Device Tree Blob）：编译后的二进制文件，内核在启动时会加载DTB文件，从其中获取硬件信息。</p>
<p> 使用dtc命令可以将DTS文件编译成DTB文件。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dtc -I dts -O dtb -o my_device.dtb my_device.dts</span><br></pre></td></tr></table></figure>

<ul>
<li>dtc：命令</li>
<li>-I dts：指定输入文件格式为DTS</li>
<li>-O dtb：指定输出文件格式为DTB</li>
<li>-o my_device.dtb：指定输出DTB的名称</li>
<li>my_device.dts：指定输入的DTS的名称</li>
</ul>
</li>
</ul>
<h2 id="2、设备树的框架"><a href="#2、设备树的框架" class="headerlink" title="2、设备树的框架"></a>2、设备树的框架</h2><h5 id="1、设备的组织结构：树形结构"><a href="#1、设备的组织结构：树形结构" class="headerlink" title="1、设备的组织结构：树形结构"></a>1、设备的组织结构：树形结构</h5><p>​	设备树采用树形结构来描述硬件平台的组成和连接关系。</p>
<ul>
<li><p>根节点（root node）：用<code>/</code>表示，是设备树的顶层节点，描述着整个硬件平台的基本信息。</p>
</li>
<li><p>子节点（child node）：根节点下的节点，描述平台生的各个设备，例如CPU、内存、总线、外设等。子节点也可以有自己的子节点。</p>
</li>
<li><p>父节点（parent node）和子节点（child node）：节点之间通过父子关系链接起来，表示设备之间的层次关系和链接关系。</p>
<p> 示例：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/ &#123; // 根节点</span><br><span class="line">    compatible = &quot;my-company,my-platform&quot;;</span><br><span class="line">    model = &quot;My Platform v1.0&quot;;</span><br><span class="line"></span><br><span class="line">    cpus &#123; // CPU 节点</span><br><span class="line">        cpu@0 &#123; // 第一个 CPU 节点</span><br><span class="line">            compatible = &quot;arm,cortex-a9&quot;;</span><br><span class="line">            reg = &lt;0x0&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    memory &#123; // 内存节点</span><br><span class="line">        reg = &lt;0x40000000 0x10000000&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    uart0: uart@1000 &#123; // UART 节点</span><br><span class="line">        compatible = &quot;ns16550a&quot;;</span><br><span class="line">        reg = &lt;0x1000 0x100&gt;;</span><br><span class="line">        interrupts = ;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    i2c0: i2c@2000 &#123; // I2C 控制器节点</span><br><span class="line">        compatible = &quot;i2c-designware&quot;;</span><br><span class="line">        reg = &lt;0x2000 0x100&gt;;</span><br><span class="line"></span><br><span class="line">        eeprom@50 &#123; // 连接在 i2c0 上的 EEPROM 芯片节点</span><br><span class="line">            compatible = &quot;atmel,24c32&quot;;</span><br><span class="line">            reg = &lt;0x50&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="2、设备树的语法规则"><a href="#2、设备树的语法规则" class="headerlink" title="2、设备树的语法规则"></a>2、设备树的语法规则</h5><p>​	设备树使用Device Tree Source（DTS）的文本格式进行描述，类似于C语言的结构体。</p>
<ul>
<li><p>节点定义：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[label:] node-name@unit-address &#123;</span><br><span class="line">    properties;</span><br><span class="line">    child-nodes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>label：节点标签，用于在其他地方使用该节点时，可选。例如uart0、i2c0</li>
<li>node-name：节点名称，描述设备的类型。例如CPU、memory、uart。</li>
<li>unit-address：节点地址，用于区分同一类型的设备，可选。例如@0200.</li>
<li>properties：节点属性，描述设备的具体属性。</li>
<li>child-nodes：节点的子节点。</li>
</ul>
</li>
<li><p>属性定义：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">property-name = value;</span><br></pre></td></tr></table></figure>

<pre><code>  * property-name：属性名称，是一个字符串。例如compatible、reg、interrups。
  * value：属性的值。
</code></pre>
</li>
<li><p>包含头文件</p>
<ul>
<li>使用<code>#include</code>指令可以包含其他的DTS文件或者DTSI文件。</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;header.dtsi&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="3、设备树的重要概念"><a href="#3、设备树的重要概念" class="headerlink" title="3、设备树的重要概念"></a>3、设备树的重要概念</h5><ul>
<li><p>compatible 属性：它时设备树中最重要的属性之一，它表示一个字符串列表，用于驱动程序和设备进行匹配。驱动程序会查找设备树中compatible属性包含其支持的字符串节点，如果匹配成功，则驱动程序就负责管理该设备。</p>
<p> 例如：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">compatible = &quot;ns16550a&quot;, &quot;uart16550&quot;;</span><br></pre></td></tr></table></figure>

<p> 表示该设备兼容ns16550a和uart16550两种类型的驱动程序。</p>
</li>
<li><p>model属性：用于指定设备的制造商和型号。</p>
<p>  例如：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">model = &quot;EmbedFire LubanCat2 HDMI+MIPI&quot;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>status属性：用于指示设备的操作状态，通过status去禁止设备或者启用设备。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* External sound card */</span><br><span class="line">sound: sound &#123;</span><br><span class="line">    status = &quot;disabled&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>  | 状态值   | 描述                                  |</p>
</li>
</ul>
<p>| ——– | ————————————- |<br>    | okay     | 使能设备                              |<br>    | disabled | 禁用设备                              |<br>    | fail     | 表示设备不可运行，                    |<br>    | fail-sss | 表示设备不可运行，sss与具体的设备相关 |</p>
<ul>
<li><p>reg属性：用于描述地址空间资源，通常包含设备的起始地址和大小。</p>
<p>  例如：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg = &lt;0x1000 0x100&gt;;</span><br></pre></td></tr></table></figure>

<p>  表示的意思是设备的其实地址是0x1000，大小为0x100字节。</p>
</li>
<li><p>interrupt属性：用于描述设备的中断资源，通产包含中断号和中断触发方式。</p>
</li>
<li><p>追加&#x2F;修改节点内容</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;cpu0 &#123;</span><br><span class="line">    cpu-supply = &lt;&amp;vdd_cpu&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>  这些代码并不包含在根节点下，他们不是一个新的节点，而是像原有的节点追加内容。在上面的例子中，&amp;cpu0表示像节点标签cpu0的节点追加数据，这个节点可能定义在泵文件也可以定义在迸溅所包含的设备树文件中。</p>
</li>
<li><p>特殊节点</p>
<ul>
<li><p>aliases子节点</p>
<p>  aliases子节点的作用就是为其他节点起一个别名，示例：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    aliases &#123;</span><br><span class="line">            csi2dphy0 = &amp;csi2_dphy0;</span><br><span class="line">            csi2dphy1 = &amp;csi2_dphy1;</span><br><span class="line">            csi2dphy2 = &amp;csi2_dphy2;</span><br><span class="line">    /*----------- 省略------------*/</span><br><span class="line">            mmc0 = &amp;sdhci;</span><br><span class="line">            mmc1 = &amp;sdmmc0;</span><br><span class="line">            mmc2 = &amp;sdmmc1;</span><br><span class="line">            mmc3 = &amp;sdmmc2;</span><br><span class="line">            serial0 = &amp;uart0;</span><br><span class="line">            serial1 = &amp;uart1;</span><br><span class="line">            serial2 = &amp;uart2;</span><br><span class="line">    /*----------- 以下省略------------*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  以serual0 &#x3D; &amp;uart0为例，serial0是一个节点的名字，设置别名后我门可以使用serial0来指代uart0节点。</p>
</li>
<li><p>chsen子节点</p>
<p>  chosen子节点位于根节点下，示例：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chosen &#123;</span><br><span class="line">          bootargs = &quot;earlycon=uart8250,mmio32,0xfe660000 console=ttyFIQ0 root=PARTUUID=614e0000-0000 rw rootwait&quot;;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>  chosen子节点不代表实际硬件，它主要用于内核传递参数。此外这个节点还可以用作uboot像linux内核传递配置参数的通道，我梦在uboot设置好参数，就是通过这个节点向内核中传递的。</p>
</li>
</ul>
</li>
</ul>
<h5 id="3、如何获取设备树节点信息"><a href="#3、如何获取设备树节点信息" class="headerlink" title="3、如何获取设备树节点信息"></a>3、如何获取设备树节点信息</h5><p>​	在设备树中‘’节点‘’对应着实际硬件中的设备，我梦在设备树中田间一个led节点，正常情况下我们可以从这个节点获取编写led驱动所用的所有信息。</p>
<p>​	在内核中提供了一组函数用于从设备节点中获取资源的函数，这些函数以of_开头，称为OF操作。</p>
<p>1、查找节点函数</p>
<ul>
<li><p>根据节点路径寻找节点函数</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct device_node *of_find_node_by_path(const char *path)</span><br></pre></td></tr></table></figure>

<p>  参数：</p>
<pre><code>  * path：指定节点在设备树中的路径
</code></pre>
<p>  返回值：</p>
<ul>
<li><p>device_node：结构体指针，失败返回为NULL；成功返回一个指针，该指针中保存着设备节点的信息。</p>
</li>
<li><p>device_node结构体如下，它定义在 <code>&lt;linux/of.h&gt;</code> 头文件中：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct device_node &#123;</span><br><span class="line">    const char *name;           // 节点的名称，例如 &quot;uart@1000&quot;</span><br><span class="line">    phandle phandle;          // 节点的句柄，用于在设备树中唯一标识一个节点</span><br><span class="line">    const char *full_name;      // 节点的完整路径名，例如 &quot;/soc/uart@1000&quot;</span><br><span class="line">    struct fwnode_handle fwnode; // 用于统一访问不同类型的固件节点，如设备树、ACPI等</span><br><span class="line"></span><br><span class="line">    struct property *properties; // 指向节点属性链表的指针</span><br><span class="line">    struct property *deadprops;  // 指向已删除属性链表的指针（用于调试）</span><br><span class="line">    struct device_node *parent;  // 指向父节点的指针</span><br><span class="line">    struct device_node *child;   // 指向第一个子节点的指针</span><br><span class="line">    struct device_node *sibling; // 指向下一个兄弟节点的指针</span><br><span class="line"></span><br><span class="line">#if defined(CONFIG_OF_KOBJ)</span><br><span class="line">    struct kobject kobj;         // 用于将设备节点注册到 sysfs 文件系统中</span><br><span class="line">#endif</span><br><span class="line">    unsigned long _flags;        // 节点标志</span><br><span class="line">    void *data;                 // 用于存储驱动程序特定的数据</span><br><span class="line">#if defined(CONFIG_SPARC)</span><br><span class="line">    unsigned int unique_id;     // SPARC 平台特有的唯一 ID</span><br><span class="line">    struct of_irq_controller *irq_trans; // SPARC 平台特有的中断转换</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>name：节点中属性为name的值</p>
</li>
<li><p>phandle：节点中为device-type的值</p>
</li>
<li><p>full-name：节点的名字，在device_node结构体后面放一个字符串，full-name指向它</p>
</li>
<li><p>properties：链表，连接该节点的所有属性</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct property &#123;</span><br><span class="line">    char *name;         // 属性的名称，例如 &quot;compatible&quot;、&quot;reg&quot;</span><br><span class="line">    int length;         // 属性值的长度（以字节为单位）</span><br><span class="line">    void *value;        // 指向属性值的指针</span><br><span class="line">    struct property *next; // 指向下一个属性的指针，构成链表</span><br><span class="line">    unsigned long _flags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>parent：指向父节点</p>
</li>
<li><p>child：指向子节点</p>
</li>
<li><p>sibling：指向兄弟节点</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>根据系欸但名字寻找节点函数</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct device_node *of_find_node_by_name(struct device_node *from,const char *name);</span><br></pre></td></tr></table></figure>

<p>  参数：</p>
<ul>
<li>from：致电给从哪个节点开始查找，它本身不在查找行列中，之查找它之后的节点。</li>
<li>name：要寻找的节点名。</li>
</ul>
<p>  返回值：</p>
<pre><code>  * device—node：节点结构体指针，上面的一样。
</code></pre>
</li>
<li><p>根据节点类型寻找节点函数</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct device_node *of_find_node_by_type(struct device_node *from,const char *type)</span><br></pre></td></tr></table></figure>

<p>  参数：</p>
<ul>
<li>from：指定从哪个节点开始找。</li>
<li>type：要寻找的节点的类型。</li>
</ul>
<p>  返回值：</p>
<ul>
<li><strong>device_node：</strong> device_node类型的结构体指针。</li>
</ul>
</li>
<li><p>根据节点类型和compeatible属性寻找节点函数</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct device_node *of_find_compatible_node(struct device_node *from,const char *type, const char *compatible)</span><br></pre></td></tr></table></figure>

<p>  相对于of_find_node_by_name，多了一个compatible（属性）的参数。</p>
<p>  compatible：要寻找的节点的兼容性属性。</p>
</li>
<li><p>根据匹配表寻找节点函数</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static inline struct device_node *of_find_matching_node_and_match(struct device_node *from, const struct of_device_id *matches, const struct of_device_id **match)</span><br></pre></td></tr></table></figure>

<p>  相对于前面的几种，多了matches、match参数。</p>
<p>  matches：指向一个of_device_id数组的指针。这个数组包含了要匹配的设备ID列表。</p>
<p>  match：指向of_device_id指针的指针。如果找到匹配的节点，则将匹配的结构体的地址存储在这个指针指向的位置。</p>
<p>  struct of_device_id结构体：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Struct used for matching a device</span><br><span class="line"> */</span><br><span class="line">struct of_device_id &#123;</span><br><span class="line">	char	name[32];</span><br><span class="line">	char	type[32];</span><br><span class="line">	char	compatible[128];</span><br><span class="line">	const void *data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>name：设备的名称。</li>
<li>type：设备的类型。</li>
<li>compatible：设备的兼容性字符串。用于驱动和设备的匹配。</li>
<li>data：指向驱动私有数据的指针。</li>
</ul>
</li>
<li><p>寻找父节点函数</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct device_node *of_get_parent(const struct device_node *node)</span><br></pre></td></tr></table></figure>

<p>  参数：</p>
<ul>
<li>node：指定要查找父节点的节点。</li>
</ul>
<p>  返回值：</p>
<ul>
<li>node：是一个指向device_node类型的结构体指针。</li>
</ul>
</li>
<li><p>寻找子节点函数</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct device_node *of_get_next_child(const struct device_node *node, struct device_node *prev)</span><br></pre></td></tr></table></figure>

<ul>
<li>node：指定谁要查找它的子节点。</li>
<li>prev：前一个子节点。这是一个迭代的过程。就像找孙子，你要先把哪个儿子的节点找到，才能找到该儿子下的孙子节点。如果为NULL，则直接找儿子节点。</li>
</ul>
</li>
</ul>
<p>这里介绍的七个寻找节点函数，共同点是返回值类型都相同。只要找到节点就可以返回节点对应的device-node结构体，通过这个结构体就可以获取到设备节点中的属性信息、父子节点等。</p>
<p>第一个函数of_find_node_by_path与其他六个不同，它是通过节点路径来寻找节点的，节点路径是从设备树源文件（.dts）中找到的。中间四个函数根据节点属性在某一节点之后查找相符合的要求的设备节点。最后两个根据父子系节点进行查找。</p>
<p>2、提取属性值的of函数</p>
<p>上面我们看了七个查找节点的函数，他们都是找到一个设备节点然后返回相对应的结构体指针device-node。下面我们讲解从结构体中获取我们想要的设备节点属性信息。</p>
<ul>
<li><p>查找节点属性函数</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct property *of_find_property(const struct device_node *np,const char *name,int *lenp)</span><br></pre></td></tr></table></figure>

<p>  参数：</p>
<ul>
<li>np：指定要获取的设备节点的属性信息。</li>
<li>name：属性名</li>
<li>lenp：获取等到的属性值的大小。这个指针作为输出参数，这个参数带回的值是实际获取得到的属性大小</li>
</ul>
<p>  返回值：</p>
<ul>
<li><p>property：获取的属性。而struct property *，我们称为系欸但属性结构体。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct property &#123;</span><br><span class="line">	char	*name;</span><br><span class="line">	int	length;</span><br><span class="line">	void	*value;</span><br><span class="line">	struct property *next;</span><br><span class="line">#if defined(CONFIG_OF_DYNAMIC) || defined(CONFIG_SPARC)</span><br><span class="line">	unsigned long _flags;</span><br><span class="line">#endif</span><br><span class="line">#if defined(CONFIG_OF_PROMTREE)</span><br><span class="line">	unsigned int unique_id;</span><br><span class="line">#endif</span><br><span class="line">#if defined(CONFIG_OF_KOBJ)</span><br><span class="line">	struct bin_attribute attr;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>name：属性名</li>
<li>length：属性长度</li>
<li>value：属性值</li>
<li>next：下个属性</li>
</ul>
</li>
</ul>
</li>
<li><p>读取整形属性函数</p>
<p>  读取属性函数是一组函数，分别为8、16、32、64位数据。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//8位整数读取函数</span><br><span class="line">int of_property_read_u8_array(const struct device_node *np, const char *propname, u8 *out_values, size_t sz)</span><br><span class="line"></span><br><span class="line">//16位整数读取函数</span><br><span class="line">int of_property_read_u16_array(const struct device_node *np, const char *propname, u16 *out_values, size_t sz)</span><br><span class="line"></span><br><span class="line">//32位整数读取函数</span><br><span class="line">int of_property_read_u32_array(const struct device_node *np, const char *propname, u32 *out_values, size_t sz)</span><br><span class="line"></span><br><span class="line">//64位整数读取函数</span><br><span class="line">int of_property_read_u64_array(const struct device_node *np, const char *propname, u64 *out_values, size_t sz)</span><br></pre></td></tr></table></figure>

<p>  参数：</p>
<ul>
<li>np：指定要读取那个设备节点结构体。</li>
<li>propname：指定要获取设备几点的那个属性</li>
<li>out-value：这是一个输出参数，是函数的返回值，保存读取等到的数据</li>
<li>sz：这是一个输入参数，用于设置读取的长度。</li>
</ul>
<p>  返回值：</p>
<ul>
<li>成功返回0，错误返回错误状态吗。-EINVAL（属性不存在）、-ENODATA（没有要读取的数据）、-EOVERFLOW（属性值列表太小）。</li>
</ul>
</li>
<li><p>读取字符串属性函数</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int of_property_read_string(const struct device_node *np,const char *propname,const char **out_string)</span><br></pre></td></tr></table></figure>

<p>  参数：</p>
<ul>
<li>np：要读取那个设备节点的属性</li>
<li>propname：属性名</li>
<li>out-string：获取等待字符串的指针。</li>
</ul>
<p>  返回值：</p>
<ul>
<li>成功返回0，失败返回错误状态吗</li>
</ul>
<p>  推荐使用下面的这个函数</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int of_property_read_string_index(const struct device_node *np,const char *propname, int index,const char **out_string)</span><br></pre></td></tr></table></figure>

<p>  相对于前面增加了index，用于指定读取属性值中的第几个字符串，index从零开始计数。</p>
</li>
<li><p>读取布尔型属性函数</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static inline bool of_property_read_bool(const struct device_node *np, const char *propname);</span><br></pre></td></tr></table></figure>

<p>  参数：</p>
<ul>
<li>np：要读取的那个设备节点的属性信息</li>
<li>propname：属性名</li>
</ul>
<p>  返回值：</p>
<ul>
<li>这个函数不是读取某个布尔型属性的值，仅仅读取这个属性存在或者不存在，如果想要获取值，还是建议使用“全能”函数查找节点of_find_property。</li>
</ul>
</li>
</ul>
<p>3、内存映射相关的of函数</p>
<p>在设备树的节点中大多包含一些捏村想过的属性，比如常用的reg属性。通常情况下，等到寄存器地址之后我们还要通过ioremap函数将物理地址转化为虚拟地址。现在内核提供了一些of函数，自动完成物理地址到虚拟地址的转换。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void __iomem *of_iomap(struct device_node *np, int index)</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li>np：要获取的那个设备节点的属性信息</li>
<li>index：通常情况下reg属性包含多段，index用于指定映射哪一段，从零开始</li>
</ul>
<p>返回值：</p>
<ul>
<li>成功返回转换的地址。失败返回NULL。</li>
</ul>
<p>内核也提供看常规获取地址的of函数，这些函数得到的值就是我们在设备树中设置的地址值，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int of_address_to_resource(struct device_node *dev, int index, struct resource *r)</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li>dev：指定要获取的那个设备节点的属性信息</li>
<li>index：通常情况下reg包含多端。</li>
<li>r：这是要给resource结构体，是输出桉树用于返回得到的地址信息。</li>
</ul>
<p>返回值：</p>
<ul>
<li>成功返回0，失败返回错误状态吗</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct resource &#123;</span><br><span class="line">    resource_size_t start;</span><br><span class="line">    resource_size_t end;</span><br><span class="line">    const char *name;</span><br><span class="line">    unsigned long flags;</span><br><span class="line">    unsigned long desc;</span><br><span class="line">    struct resource *parent, *sibling, *child;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>start：起始地址</li>
<li>end：结束地址</li>
<li>name：属性的名称</li>
</ul>
<h5 id="4、使用设备树驱动led示例"><a href="#4、使用设备树驱动led示例" class="headerlink" title="4、使用设备树驱动led示例"></a>4、使用设备树驱动led示例</h5><p>1、像设备树中添加节点：</p>
<ul>
<li><p>在linux内核源码中找到设备树文件。（&#x2F;home&#x2F;h&#x2F;h&#x2F;linux-5.4.31&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;dts）</p>
</li>
<li><p>打开设备树文件，在其中添加led节点。（stm32mp157a-fsmpla.dts）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> led_test@0x54004000&#123;</span><br><span class="line">      compatible = &quot;h,led1&quot;;</span><br><span class="line">      reg = &lt;0x54004000 0x400&gt;;</span><br><span class="line">      led_name = &quot;led01&quot;;</span><br><span class="line">      led_minor = &lt;11&gt;;</span><br><span class="line">      moder_clear = &lt;0x3f&gt;;</span><br><span class="line">      moder_data = &lt;0x15&gt;;</span><br><span class="line">      odr = &lt;0x7&gt;;</span><br><span class="line">      shift = &lt;5&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<pre><code>* led_test：设备节点名称。
* @0x54004000：设备的起始地址。当属性中有reg时，可以在这里添加0x54004000，当然有没有并没有什么影响。
* compatible：用于匹配驱动程序。
* reg：设备的寄存器空间地址。包括其实地址和空间大小。
* （下面就是自定义属性）
* led_name：设备名称。
* moder_clear：清理GPIO引脚的输入输出端口。
* moder_data：配置GPIO引脚。
* odr：输出数据寄存器的值。决定了led的初始状态。
* shift：寄存器的位移量。
</code></pre>
</li>
<li><p>添加好设备节点后，保存退出。</p>
</li>
<li><p>进入linux内核目录下进行编译，重新传入板子中。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">h@h-virtual-machine:~/h/linux-5.4.31$ source /opt/stm32_sdk/environment-setup-cortexa7t2hf-neon-vfpv4-ostl-linux-gnueabi </span><br><span class="line">h@h-virtual-machine:~/h/linux-5.4.31$ make -j4 ARCH=arm dtbs LOADADDR=0xC2000040</span><br><span class="line">cp arch/arm/boot/dts/stm32mp157a-fsmpla.dtb /tftpboot/</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新启动单片机，linux内核就会重新加载我们新写好的设备树文件。</p>
</li>
</ul>
<p>2、编写驱动代码（led_pdrv.c）</p>
<ul>
<li><p>编写驱动框架</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int __init led_pdev_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    printk(&quot;--------- %s ---------\n&quot;, __FUNCTION__);</span><br><span class="line">    // 2、注册platform-driver对象</span><br><span class="line">    return platform_driver_register(&amp;led_pdrv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __exit led_pdrv_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">    printk(&quot;--------- %s ---------\n&quot;, __FUNCTION__);</span><br><span class="line">    platform_driver_unregister(&amp;led_pdrv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(led_pdev_init);</span><br><span class="line">module_exit(led_pdrv_exit);</span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建platform-driver对象，并且通过led_match_table中的compatible与驱动进行匹配。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 与pdev中的name匹配</span><br><span class="line">const struct platform_device_id led_id_table[] = &#123;</span><br><span class="line">    &#123; &quot;mp157_led&quot;, 0xa &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 与设备树中的compatible匹配</span><br><span class="line">const struct of_device_id led_match_table[] = &#123;</span><br><span class="line">    &#123; .compatible = &quot;h,led1&quot; &#125;,</span><br><span class="line">    &#123; /* sentinel */ &#125;</span><br><span class="line">&#125;;</span><br><span class="line">struct platform_driver led_pdrv = &#123;</span><br><span class="line">    .probe  = led_pdrv_probe,</span><br><span class="line">    .remove = led_pdrv_remove,</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = &quot;fsmp1_led&quot;,</span><br><span class="line">        .of_match_table = led_match_table,</span><br><span class="line">    &#125;,</span><br><span class="line">    .id_table = led_id_table,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写led_pdrv_probe、led_pdrv_remove函数，如果驱动匹配成功后，会调用led_pdrv_probe函数执行，在卸载时调用led_pdrv_remove函数。</p>
<ul>
<li><p>int led_pdrv_probe(struct platform_device *<em>pdev</em>)</p>
<ul>
<li><p>分配全局设备对象空间</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 设计led的结构体</span><br><span class="line">struct mp157_led_t &#123;</span><br><span class="line">    struct miscdevice misc;</span><br><span class="line">    unsigned int *moder;</span><br><span class="line">    unsigned int *odr;</span><br><span class="line"></span><br><span class="line">    int m_clear;</span><br><span class="line">    int m_data;</span><br><span class="line">    int o_data;</span><br><span class="line">    int shift;</span><br><span class="line">&#125;;</span><br><span class="line">    // 1、分配全局设备对象空间</span><br><span class="line">    led_dev = kzalloc(sizeof(*led_dev), GFP_KERNEL);</span><br><span class="line">    if (!led_dev) &#123;</span><br><span class="line">        printk(&quot;kzalloc failed\n&quot;);</span><br><span class="line">        return -ENOMEM;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取设备节点和数据</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 获取设备树节点对象</span><br><span class="line">np = pdev-&gt;dev.of_node;	//这里的np是直接获取pdev的设备树节点，并不是寻找到设备树节点</span><br><span class="line">of_property_read_string(np, &quot;led_name&quot;, (const char **)&amp;name);</span><br><span class="line">of_property_read_u32(np, &quot;led_minor&quot;, &amp;minor);</span><br><span class="line">of_property_read_u32(np, &quot;led_clear&quot;, &amp;led_dev-&gt;m_clear);</span><br><span class="line">of_property_read_u32(np, &quot;moder_data&quot;, &amp;led_dev-&gt;o_data);</span><br><span class="line">of_property_read_u32(np, &quot;odr&quot;, &amp;led_dev-&gt;o_data);  // 修正：读取odr属性，赋值给o_data</span><br><span class="line">of_property_read_u32(np, &quot;shift&quot;, &amp;led_dev-&gt;shift);</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化杂项设备</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">led_dev-&gt;misc.name = name;</span><br><span class="line">led_dev-&gt;misc.minor = minor;</span><br><span class="line">led_dev-&gt;misc.fops = &amp;led_fops;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注册杂项设备</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ret = misc_register(&amp;led_dev-&gt;misc);</span><br><span class="line">if (ret) &#123;</span><br><span class="line">    printk(&quot;misc register failed\n&quot;);</span><br><span class="line">    goto err_kfree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>硬件初始化</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">led_dev-&gt;moder = ioremap(res1-&gt;start, res1-&gt;end - res1-&gt;start + 1);</span><br><span class="line">if (!led_dev-&gt;moder) &#123;</span><br><span class="line">    printk(&quot;ioremap failed\n&quot;);</span><br><span class="line">    ret = -EINVAL;</span><br><span class="line">    goto err_misc_deregister;</span><br><span class="line">&#125;</span><br><span class="line">led_dev-&gt;odr = led_dev-&gt;moder + 5;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>int led_pdrv_remove(struct platform_device *<em>pdev</em>)</p>
<ul>
<li><p>平台资源的释放和注销（先注册后释放）</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printk(&quot;--------- %s ---------\n&quot;, __FUNCTION__);</span><br><span class="line">iounmap(led_dev-&gt;moder);</span><br><span class="line">misc_deregister(&amp;led_dev-&gt;misc);</span><br><span class="line">kfree(led_dev);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>编写文件操作函数open、write、release。</p>
<ul>
<li><p>首先定义结构体</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const struct file_operations led_fops = &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .open   = led_pdrv_open,</span><br><span class="line">    .write  = led_pdrv_write,</span><br><span class="line">    .release  = led_pdrv_close,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>int led_pdrv_open(struct inode *<em>inode</em>, struct file *<em>filp</em>)</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 将GPIOZ——5、6、7设置成输出模式</span><br><span class="line">*led_dev-&gt;moder &amp;= ~(led_dev-&gt;m_clear &lt;&lt; (led_dev-&gt;shift * 2));</span><br><span class="line">*led_dev-&gt;moder |= led_dev-&gt;m_data  &lt;&lt; (led_dev-&gt;shift * 2);</span><br></pre></td></tr></table></figure>
</li>
<li><p>ssize_t led_pdrv_write(struct file *<em>filp</em>, const char __user *<em>buf</em>, size_t <em>size</em>, <em>loff_t</em> *<em>flags</em>)</p>
<ul>
<li><p>将应用数据转换为内核数据</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ret = copy_from_user(&amp;value, buf, size);</span><br><span class="line">if (ret) &#123;</span><br><span class="line">    printk(&quot;copy from user error\n&quot;);</span><br><span class="line">    return -EAGAIN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据传输的值进行开关灯</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (value) &#123;   // 开灯</span><br><span class="line">    *led_dev-&gt;odr |= led_dev-&gt;o_data &lt;&lt; led_dev-&gt;shift;</span><br><span class="line">&#125; else &#123;  // 关灯</span><br><span class="line">    *led_dev-&gt;odr &amp;= ~(led_dev-&gt;o_data &lt;&lt; led_dev-&gt;shift);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>int led_pdrv_close(struct inode *<em>inode</em>, struct file *<em>filp</em>)</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*led_dev-&gt;odr &amp;= ~(led_dev-&gt;o_data &lt;&lt; led_dev-&gt;shift);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux驱动</category>
      </categories>
      <tags>
        <tag>Linux学习</tag>
        <tag>平台总线</tag>
        <tag>设备树</tag>
        <tag>DTS</tag>
      </tags>
  </entry>
  <entry>
    <title>驱动和设备匹配过程</title>
    <url>/2025/01/14/%E9%A9%B1%E5%8A%A8%E5%92%8C%E8%AE%BE%E5%A4%87%E5%8C%B9%E9%85%8D%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="匹配过程及其问题"><a href="#匹配过程及其问题" class="headerlink" title="匹配过程及其问题"></a>匹配过程及其问题</h1><h4 id="1、匹配过程"><a href="#1、匹配过程" class="headerlink" title="1、匹配过程"></a>1、匹配过程</h4><p>​	在linux驱动中，目前学到了三种编写代码的方式。</p>
<ul>
<li><p>第一种：传统编写。驱动和硬件写在一起，让linux内核和硬件交织在一起，这是早期linux开发的编写方式，不推荐使用，可以在初学时看看，也可以不看，不影响。</p>
</li>
<li><p>第二种：使驱动和设备硬件分开编写。pdrv主要编写linux的内核代码，pdev主要关于硬件的资源。分开有利管理，但是当设备多了之后，又出现了问题，代码太多，太繁。</p>
</li>
<li><p>第三种：使用设备树。驱动的代码基本不变，修改设备硬件的代码，把使用的设备硬件汇总为一个设备树的结构，每个节点都是一个设备硬件，代码简单、方便、便于移植。</p>
<span id="more"></span></li>
</ul>
<p>第一种不说了。主要讲第二、三种的匹配过程，阅读一下内核源码，看一下整个流程。（目前刚刚开始学习不久，仅仅学到设备树，所以就目前掌握的开始写和搜的，如果以后学习到更深，在回来补充）</p>
<ul>
<li><p>平台总线的平台驱动和平台设备匹配过程</p>
<ul>
<li><p>1、首先先讲解两个函数。平台设备注册int platform_device_register(struct <em>platform_device</em> *)；平台驱动注册platform_driver_register(<em>drv</em>)。这是两个注册函数，将我们自定义的平台设备和平台驱动注册到平台总线中去。他们会在平台总线中相遇，至于怎么找到双方，那就要有一个信物，两者个持一个，匹配上了就会成功。这个信物就是name（名称），下面会讲解。</p>
<ul>
<li><p><em><em>平台设备注册：int platform_device_register(struct platform_device pdev</em>)</em>* </p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int platform_device_register(struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">	device_initialize(&amp;pdev-&gt;dev);</span><br><span class="line">	setup_pdev_dma_masks(pdev);</span><br><span class="line">	return platform_device_add(pdev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在平台设备注册函数中主要完成下面任务：</p>
<p>  1、初始化struct platform_device结构体中的struct device结构体。[它将平台设备纳入到 Linux 设备模型中，使其能够被设备模型管理和访问。](#####1、在平台设备注册函数中，为什么要初始化struct device结构体？为什么说将平台设备纳入到 Linux 设备模型中？)</p>
<p>  2、关于DMA的，这个函数用于设置设备的 DMA (Direct Memory Access) 掩码。DMA 允许设备直接访问内存，而无需 CPU 的干预，从而提高数据传输效率。DMA 掩码用于限制设备可以访问的内存地址范围。</p>
<p>  3、这个函数是平台设备的注册的真正执行着，将平台设备添加到平台总线的设备列表中。触发驱动程序等到匹配。</p>
</li>
<li><p><strong>在platform_device_add(pdev);函数中，找到源码解读。</strong><br>  1、参数检查和初始化</p>
<ul>
<li>首先检查pdev指针是否为空。</li>
<li>如果pdev的父设备为空，则将其设置成平台总线。（可见平台总线相当于根节点，下面挂着一串平台设备列表）</li>
<li>设备pdev的总线类型为平台总线类型（platform_bus_type）（<a href="#####2%E3%80%81%E5%B9%B3%E5%8F%B0%E6%80%BB%E7%BA%BF%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E5%8C%B9%E9%85%8D%E7%9A%84%E5%85%B3%E7%B3%BB">这个平台总线类型是平台匹配的重要部分</a>）。</li>
</ul>
<p>  2、设置设备名称</p>
<ul>
<li>根据 <code>pdev-&gt;id</code>的值，使用<code>dev_set_name</code>函数设备<code>pdev</code>的设备名称。</li>
<li>如果<code>pdev-&gt;id</code>为默认值，则将名称设置为<code>pdev-&gt;name.pdev-&gt;id</code>。</li>
<li>如果<code>pdev-&gt;id</code>为<code>PLATFORM_DEVID_NONE</code>，则将名称设置为<code>pdev-&gt;name</code>。</li>
<li>如果<code>pdev-&gt;id</code>为<code>PLATFORM_DEVID_AUTO</code>，则将名称设置为<code>pdev-&gt;name.pdev-&gt;id.auto</code>。</li>
</ul>
<p>  3、注册设备资源</p>
<ul>
<li>遍历<code>pdev-&gt;resource</code> 数组，该数组中存放着设备使用的资源信息（例如内存地址、中断号等）</li>
<li>为每个资源设置名称</li>
<li>为每个资源设置父资源</li>
</ul>
<p>  4、添加设备</p>
<ul>
<li>打印注册信息</li>
<li>调用 <code>device_add</code> 函数将设备添加到linux设备模型中。</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int platform_device_add(struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">	u32 i;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">	if (!pdev)</span><br><span class="line">		return -EINVAL;</span><br><span class="line"></span><br><span class="line">	if (!pdev-&gt;dev.parent)</span><br><span class="line">		pdev-&gt;dev.parent = &amp;platform_bus;</span><br><span class="line"></span><br><span class="line">	pdev-&gt;dev.bus = &amp;platform_bus_type;</span><br><span class="line"></span><br><span class="line">	switch (pdev-&gt;id) &#123;</span><br><span class="line">	default:</span><br><span class="line">		dev_set_name(&amp;pdev-&gt;dev, &quot;%s.%d&quot;, pdev-&gt;name,  pdev-&gt;id);</span><br><span class="line">		break;</span><br><span class="line">	case PLATFORM_DEVID_NONE:</span><br><span class="line">		dev_set_name(&amp;pdev-&gt;dev, &quot;%s&quot;, pdev-&gt;name);</span><br><span class="line">		break;</span><br><span class="line">	case PLATFORM_DEVID_AUTO:</span><br><span class="line">		/*</span><br><span class="line">		 * Automatically allocated device ID. We mark it as such so</span><br><span class="line">		 * that we remember it must be freed, and we append a suffix</span><br><span class="line">		 * to avoid namespace collision with explicit IDs.</span><br><span class="line">		 */</span><br><span class="line">		ret = ida_simple_get(&amp;platform_devid_ida, 0, 0, GFP_KERNEL);</span><br><span class="line">		if (ret &lt; 0)</span><br><span class="line">			goto err_out;</span><br><span class="line">		pdev-&gt;id = ret;</span><br><span class="line">		pdev-&gt;id_auto = true;</span><br><span class="line">		dev_set_name(&amp;pdev-&gt;dev, &quot;%s.%d.auto&quot;, pdev-&gt;name, pdev-&gt;id);</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (i = 0; i &lt; pdev-&gt;num_resources; i++) &#123;</span><br><span class="line">		struct resource *p, *r = &amp;pdev-&gt;resource[i];</span><br><span class="line"></span><br><span class="line">		if (r-&gt;name == NULL)</span><br><span class="line">			r-&gt;name = dev_name(&amp;pdev-&gt;dev);</span><br><span class="line"></span><br><span class="line">		p = r-&gt;parent;</span><br><span class="line">		if (!p) &#123;</span><br><span class="line">			if (resource_type(r) == IORESOURCE_MEM)</span><br><span class="line">				p = &amp;iomem_resource;</span><br><span class="line">			else if (resource_type(r) == IORESOURCE_IO)</span><br><span class="line">				p = &amp;ioport_resource;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (p) &#123;</span><br><span class="line">			ret = insert_resource(p, r);</span><br><span class="line">			if (ret) &#123;</span><br><span class="line">				dev_err(&amp;pdev-&gt;dev, &quot;failed to claim resource %d: %pR\n&quot;, i, r);</span><br><span class="line">				goto failed;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pr_debug(&quot;Registering platform device &#x27;%s&#x27;. Parent at %s\n&quot;,</span><br><span class="line">		 dev_name(&amp;pdev-&gt;dev), dev_name(pdev-&gt;dev.parent));</span><br><span class="line"></span><br><span class="line">	ret = device_add(&amp;pdev-&gt;dev);</span><br><span class="line">	if (ret == 0)</span><br><span class="line">		return ret;</span><br><span class="line"></span><br><span class="line"> failed:</span><br><span class="line">	if (pdev-&gt;id_auto) &#123;</span><br><span class="line">		ida_simple_remove(&amp;platform_devid_ida, pdev-&gt;id);</span><br><span class="line">		pdev-&gt;id = PLATFORM_DEVID_AUTO;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	while (i--) &#123;</span><br><span class="line">		struct resource *r = &amp;pdev-&gt;resource[i];</span><br><span class="line">		if (r-&gt;parent)</span><br><span class="line">			release_resource(r);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"> err_out:</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注册平台设备需要一个struct platform_device *<em>pdev</em>结构体，具体内容如下：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct platform_device &#123;</span><br><span class="line">	const char	*name;</span><br><span class="line">	int		id;</span><br><span class="line">	bool		id_auto;</span><br><span class="line">	struct device	dev;</span><br><span class="line">	u64		platform_dma_mask;</span><br><span class="line">	u32		num_resources;</span><br><span class="line">	struct resource	*resource;</span><br><span class="line"></span><br><span class="line">	const struct platform_device_id	*id_entry;</span><br><span class="line">	char *driver_override; /* Driver name to force a match */</span><br><span class="line"></span><br><span class="line">	/* MFD cell pointer */</span><br><span class="line">	struct mfd_cell *mfd_cell;</span><br><span class="line"></span><br><span class="line">	/* arch specific additions */</span><br><span class="line">	struct pdev_archdata	archdata;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>平台驱动注册函数platform_driver_register(<em>drv</em>)</strong> </p>
<ul>
<li><p>在linux内核代码中定义了一个宏定义关于平台驱动注册函数。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define platform_driver_register(drv) \</span><br><span class="line">	__platform_driver_register(drv, THIS_MODULE)</span><br><span class="line">extern int __platform_driver_register(struct platform_driver *,</span><br><span class="line">					struct module *);</span><br></pre></td></tr></table></figure>

<p>  在其中我们可以看到platform_driver_register是通过宏定义代表__platform_driver_register这个函数的。在函数中有两个参数分别是platform_driver *、struct module *。其中我们重要关心的是platform_driver 结构体，这里的和上面已经讲过的platform_device一样，是在linux内核定义好的设备框架基础上田间自定义的构建成的。</p>
</li>
<li><p>在__platform_driver_register结构体中的源码如下：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __platform_driver_register(struct platform_driver *drv,</span><br><span class="line">				struct module *owner)</span><br><span class="line">&#123;</span><br><span class="line">	drv-&gt;driver.owner = owner;</span><br><span class="line">	drv-&gt;driver.bus = &amp;platform_bus_type;</span><br><span class="line">	drv-&gt;driver.probe = platform_drv_probe;</span><br><span class="line">	drv-&gt;driver.remove = platform_drv_remove;</span><br><span class="line">	drv-&gt;driver.shutdown = platform_drv_shutdown;</span><br><span class="line"></span><br><span class="line">	return driver_register(&amp;drv-&gt;driver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  首先对driver进行一些初始化。在其中我们关心的是<code>drv-&gt;driver.bus = &amp;platform_bus_type;</code> 、<code>drv-&gt;driver.probe = platform_drv_probe;</code>、 <code>drv-&gt;driver.remove = platform_drv_remove;</code> 这三个行代码，其中driver.bus指定了总线类型，也是与设备匹配的关键。下面两个probe、remove两个是一个中间层函数，他们会获取platform_device的信息，然后调用我们在platform_device中自定义的probe函数。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2、匹配中的各种问题"><a href="#2、匹配中的各种问题" class="headerlink" title="2、匹配中的各种问题"></a>2、匹配中的各种问题</h4><h5 id="1、在平台设备注册函数中，为什么要初始化struct-device结构体？为什么说将平台设备纳入到-Linux-设备模型中？"><a href="#1、在平台设备注册函数中，为什么要初始化struct-device结构体？为什么说将平台设备纳入到-Linux-设备模型中？" class="headerlink" title="1、在平台设备注册函数中，为什么要初始化struct device结构体？为什么说将平台设备纳入到 Linux 设备模型中？"></a>1、在平台设备注册函数中，为什么要初始化struct device结构体？为什么说将平台设备纳入到 Linux 设备模型中？</h5><p>​	1、struct device是linux设备模型的基础，所有的设备都必须通过struct device纳入到设备模型中才能够被内核有效的管理。</p>
<p>​	2、linux设备模型是内核中用于管理所有设备的框架，它提供了一套统一的接口和机制。在linux中所有的设备，例如平台设备、PCI设备、USB设备，这些统一是在框架的基础上写入一些自定义的构成的。</p>
<h5 id="2、平台总线类型和平台匹配的关系。"><a href="#2、平台总线类型和平台匹配的关系。" class="headerlink" title="2、平台总线类型和平台匹配的关系。"></a>2、平台总线类型和平台匹配的关系。</h5><p>​	1、平台总线类型的源码如下，其中 <code>struct bus_type platform_bus_type</code> 定义了平台总线的类型。在liunx设备模型中，总线类型是链接设备和驱动程序的桥梁。平台总线是一中虚拟的总线，用于管理那些无法通过标准总线（如PCI、USB）枚举的设备。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct bus_type platform_bus_type = &#123;</span><br><span class="line">	.name		= &quot;platform&quot;,</span><br><span class="line">	.dev_groups	= platform_dev_groups,</span><br><span class="line">	.match		= platform_match,</span><br><span class="line">	.uevent		= platform_uevent,</span><br><span class="line">	.dma_configure	= platform_dma_configure,</span><br><span class="line">	.pm		= &amp;platform_dev_pm_ops,</span><br><span class="line">&#125;;</span><br><span class="line">struct bus_type &#123;</span><br><span class="line">	const char		*name;</span><br><span class="line">	const char		*dev_name;</span><br><span class="line">	struct device		*dev_root;</span><br><span class="line">	const struct attribute_group **bus_groups;</span><br><span class="line">	const struct attribute_group **dev_groups;</span><br><span class="line">	const struct attribute_group **drv_groups;</span><br><span class="line"></span><br><span class="line">	int (*match)(struct device *dev, struct device_driver *drv);</span><br><span class="line">	int (*uevent)(struct device *dev, struct kobj_uevent_env *env);</span><br><span class="line">	int (*probe)(struct device *dev);</span><br><span class="line">	int (*remove)(struct device *dev);</span><br><span class="line">	void (*shutdown)(struct device *dev);</span><br><span class="line"></span><br><span class="line">	int (*online)(struct device *dev);</span><br><span class="line">	int (*offline)(struct device *dev);</span><br><span class="line"></span><br><span class="line">	int (*suspend)(struct device *dev, pm_message_t state);</span><br><span class="line">	int (*resume)(struct device *dev);</span><br><span class="line"></span><br><span class="line">	int (*num_vf)(struct device *dev);</span><br><span class="line"></span><br><span class="line">	int (*dma_configure)(struct device *dev);</span><br><span class="line"></span><br><span class="line">	const struct dev_pm_ops *pm;</span><br><span class="line"></span><br><span class="line">	const struct iommu_ops *iommu_ops;</span><br><span class="line"></span><br><span class="line">	struct subsys_private *p;</span><br><span class="line">	struct lock_class_key lock_key;</span><br><span class="line"></span><br><span class="line">	bool need_parent_lock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2、在上面说的两个结构体中，有两个函数关乎与匹配相关。<code>.match		= platform_match,</code> 、<code>int (*match)(struct device *dev, struct device_driver *drv);</code> 。下面是 <code>platform_match</code> 的代码。</p>
<ul>
<li>在开始时传入设备和驱动的结构体。</li>
<li>检查 <code>driver_override</code> 参数是 否被设置。<code>driver_override</code> 允许用户强制指定设备要使用的驱动程序。</li>
<li>首先尝试使用设备树，在<code>of_driver_match_device</code> 函数中会根据设备树中的 <code>compatible</code> 属性里匹配设备和驱动程序。成功则直接返回。</li>
<li>然后在尝试ACPI（Advanced Configuration and Power Interface）进行匹配。在 <code>acpi_driver_match_device</code> 函数中会根据ACPI描述符进行匹配。成功则直接返回。</li>
<li>如果定义了<code>id_table</code> 尝试使用ID表进行匹配。</li>
<li>如果上面的匹配都失败了，则尝试使用设备的名称和驱动的名称进行匹配。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int platform_match(struct device *dev, struct device_driver *drv)</span><br><span class="line">&#123;</span><br><span class="line">	struct platform_device *pdev = to_platform_device(dev);</span><br><span class="line">	struct platform_driver *pdrv = to_platform_driver(drv);</span><br><span class="line"></span><br><span class="line">	/* When driver_override is set, only bind to the matching driver */</span><br><span class="line">	if (pdev-&gt;driver_override)</span><br><span class="line">		return !strcmp(pdev-&gt;driver_override, drv-&gt;name);</span><br><span class="line"></span><br><span class="line">	/* Attempt an OF style match first */</span><br><span class="line">	if (of_driver_match_device(dev, drv))</span><br><span class="line">		return 1;</span><br><span class="line"></span><br><span class="line">	/* Then try ACPI style match */</span><br><span class="line">	if (acpi_driver_match_device(dev, drv))</span><br><span class="line">		return 1;</span><br><span class="line"></span><br><span class="line">	/* Then try to match against the id table */</span><br><span class="line">	if (pdrv-&gt;id_table)</span><br><span class="line">		return platform_match_id(pdrv-&gt;id_table, pdev) != NULL;</span><br><span class="line"></span><br><span class="line">	/* fall-back to driver name match */</span><br><span class="line">	return (strcmp(pdev-&gt;name, drv-&gt;name) == 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux驱动</category>
      </categories>
      <tags>
        <tag>Linux学习</tag>
        <tag>平台驱动</tag>
        <tag>平台设备</tag>
        <tag>平台匹配</tag>
      </tags>
  </entry>
</search>
